https://www.cplusplus.com/reference/regex/ssub_match/
This is an instantiation of the sub_match class template for matches on string objects.The members of this class are those described in sub_match, but using string::const_iterator as its BidirectionalIterator template parameter.Please, refer to sub_match for further information.
https://www.cplusplus.com/reference/chrono/steady_clock/
Clock classes provide access to the current time_point.steady_clock is specifically designed to calculate time intervals.
https://www.cplusplus.com/reference/codecvt/codecvt_utf8/
locale::facetcodecvt_basecodecvtcodecvt_utf8Converts between multibyte sequences encoded in UTF-8 and sequences of their equivalent fixed-width characters of type Elem (either UCS-2 or UCS-4).Notice that if Elem is a 32bit-width character type (such as char32_t), and MaxCode is 0x10ffff, the conversion performed is between UTF-8 and UTF-32. For 16bit-width character types, this class would only generate code points that do not require surrogates (plain old UCS-2). To convert from UTF-8 to UTF-16 (both being variable-width encodings) or the other way around, see codecvt_utf8_utf16 instead.The facet uses Elem as its internal character type, and char as its external character type (encoded as UTF-8). Therefore:Member in converts from UTF-8 to its fixed-width character equivalent.Member out converts from the fixed-width wide character encoding to UTF-8.
https://www.cplusplus.com/reference/regex/basic_regex/
A regular expression is an object defining a particular pattern to be matched against a sequence of characters using the tools of the standard regex library.Such objects are essentially constructed from a sequence of characters that can include several wildcards and constraints to define the set of rules (the pattern) that make a sequence of characters qualify as a match. By default, regex patterns follow the ECMAScript syntax.basic_regex object do not conduct the matches directly through any of its members. Instead, they are used as arguments for regex algorithms (regex_match, regex_search and regex_replace) and regex iterator adaptors (regex_iterator and regex_token_iterator) that perform these matches using the rules specified when constructing the basic_regex object.Two instantiations of this basic class exist in the standard header <regex> for the most common cases:12typedef basic_regex<char>    regex;typedef basic_regex<wchar_t> wregex;
https://www.cplusplus.com/reference/set/multiset/
Multisets are containers that store elements following a specific order, and where multiple elements can have equivalent values.In a multiset, the value of an element also identifies it (the value is itself the key, of type T). The value of the elements in a multiset cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container.Internally, the elements in a multiset are always sorted following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).multiset containers are generally slower than unordered_multiset containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.Multisets are typically implemented as binary search trees.
https://www.cplusplus.com/reference/codecvt/codecvt_utf8_utf16/
locale::facetcodecvt_basecodecvtcodecvt_16Converts between multibyte sequences encoded in UTF-8 and UTF-16.The facet uses Elem as its internal character type (encoded as UTF-16), and char as its external character type (encoded as UTF-8). Therefore:Member in converts from UTF-8 to UTF-16.Member out converts from UTF-16 to UTF-8.
https://www.cplusplus.com/reference/utility/piecewise_construct_t/
Type of the piecewise_construct constant.This is a type specifically designed to overload a specific pair constructor.It is an empty class defined in header <utility>. This header also defines the standard constant piecewise_construct, which is a value of this type specifically designed to call the overloaded constructor.
https://www.cplusplus.com/reference/atomic/memory_order/
Used as an argument to functions that conduct atomic operations to specify how other operations on different threads are synchronized.It is defined as:12345678typedef enum memory_order {    memory_order_relaxed,   // relaxed    memory_order_consume,   // consume    memory_order_acquire,   // acquire    memory_order_release,   // release    memory_order_acq_rel,   // acquire/release    memory_order_seq_cst    // sequentially consistent} memory_order;All atomic operations produce well-defined behavior with respect to an atomic object when multiple threads access it: each atomic operation is entirely performed on the object before any other atomic operation can access it. This guarantees no data races on these objects, and this is precisely the feature that defines atomicity.But each thread may perform operations on memory locations other than the atomic object itself: and these other operations may produce visible side effects on other threads. Arguments of this type allow to specify a memory order for the operation that determines how these (possibly non-atomic) visible side effects are synchronized among threads, using the atomic operations as synchronization points:memory_order_relaxedThe operation is ordered to happen atomically at some point.This is the loosest memory order, providing no guarantees on how memory accesses in different threads are ordered with respect to the atomic operation.memory_order_consume[Applies to loading operations]The operation is ordered to happen once all accesses to memory in the releasing thread that carry a dependency on the releasing operation (and that have visible side effects on the loading thread) have happened.memory_order_acquire[Applies to loading operations]The operation is ordered to happen once all accesses to memory in the releasing thread (that have visible side effects on the loading thread) have happened.memory_order_release[Applies to storing operations]The operation is ordered to happen before a consume or acquire operation, serving as a synchronization point for other accesses to memory that may have visible side effects on the loading thread.memory_order_acq_rel[Applies to loading/storing operations]The operation loads acquiring and stores releasing (as defined above for memory_order_acquire and memory_order_release).memory_order_seq_cstThe operation is ordered in a sequentially consistent manner: All operations using this memory order are ordered to happen once all accesses to memory that may have visible side effects on the other threads involved have already happened.This is the strictest memory order, guaranteeing the least unexpected side effects between thread interactions though the non-atomic memory accesses.For consume and acquire loads, sequentially consistent store operations are considered releasing operations.
https://www.cplusplus.com/reference/queue/priority_queue/
Priority queues are a type of container adaptors, specifically designed such that its first element is always the greatest of the elements it contains, according to some strict weak ordering criterion.This context is similar to a heap, where elements can be inserted at any moment, and only the max heap element can be retrieved (the one at the top in the priority queue).Priority queues are implemented as container adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are popped from the "back" of the specific container, which is known as the top of the priority queue.The underlying container may be any of the standard container class templates or some other specifically designed container class. The container shall be accessible through random access iterators and support the following operations:empty()size()front()push_back()pop_back()The standard container classes vector and deque fulfill these requirements. By default, if no container class is specified for a particular priority_queue class instantiation, the standard container vector is used.Support of random access iterators is required to keep a heap structure internally at all times. This is done automatically by the container adaptor by automatically calling the algorithm functions make_heap, push_heap and pop_heap when needed.
https://www.cplusplus.com/reference/ratio/ratio_not_equal/
This type inherits from the appropriate integral_constant type (either true_type or false_type) to signal whether R1 compares not equal to R2The resulting type is the same as if ratio_not_equal was defined as:12template <class R1, class R2>struct ratio_not_equal : integral_constant < bool, !ratio_equal<R1,R2>::value > {};
https://www.cplusplus.com/reference/regex/csub_match/
This is an instantiation of the sub_match class template for matches on string literals of type const char*.The members of this class are those described for sub_match, but using const char* as its BidirectionalIterator template parameter.Please, refer to sub_match for further information.
https://www.cplusplus.com/
Header with library support for width-based integral types.Including this header automatically includes also <cstdint> (which defines width-based integral types).
https://www.cplusplus.com/reference/regex/wcmatch/
This is an instantiation of the match_results class template for matches on wide string literals (with const wchar_t* as its iterator type).The members of this class are those described for match_results, but using const wchar_t* as its BidirectionalIterator template parameter.Please, refer to match_results for further information.
https://www.cplusplus.com/reference/system_error/errc/
This enum class type defines the error conditions of the generic category.The value of each label is the same as the value defined for the equivalent errno value.errc labelerrno equivalent*address_family_not_supportedEAFNOSUPPORTaddress_in_useEADDRINUSEaddress_not_availableEADDRNOTAVAILalready_connectedEISCONNargument_list_too_longE2BIGargument_out_of_domainEDOMbad_addressEFAULTbad_file_descriptorEBADFbad_messageEBADMSGbroken_pipeEPIPEconnection_abortedECONNABORTEDconnection_already_in_progressEALREADYconnection_refusedECONNREFUSEDconnection_resetECONNRESETcross_device_linkEXDEVdestination_address_requiredEDESTADDRREQdevice_or_resource_busyEBUSYdirectory_not_emptyENOTEMPTYexecutable_format_errorENOEXECfile_existsEEXISTfile_too_largeEFBIGfilename_too_longENAMETOOLONGfunction_not_supportedENOSYShost_unreachableEHOSTUNREACHidentifier_removedEIDRMillegal_byte_sequenceEILSEQinappropriate_io_control_operationENOTTYinterruptedEINTRinvalid_argumentEINVALinvalid_seekESPIPEio_errorEIOis_a_directoryEISDIRmessage_sizeEMSGSIZEnetwork_downENETDOWNnetwork_resetENETRESETnetwork_unreachableENETUNREACHno_buffer_spaceENOBUFSno_child_processECHILDno_linkENOLINKno_lock_availableENOLOCKno_messageENOMSGno_message_availableENODATAno_protocol_optionENOPROTOOPTno_space_on_deviceENOSPCno_stream_resourcesENOSRno_such_deviceENODEVno_such_device_or_addressENXIOno_such_file_or_directoryENOENTno_such_processESRCHnot_a_directoryENOTDIRnot_a_socketENOTSOCKnot_a_streamENOSTRnot_connectedENOTCONNnot_enough_memoryENOMEMnot_supportedENOTSUPoperation_canceledECANCELEDoperation_in_progressEINPROGRESSoperation_not_permittedEPERMoperation_not_supportedEOPNOTSUPPoperation_would_blockEWOULDBLOCKowner_deadEOWNERDEADpermission_deniedEACCESprotocol_errorEPROTOprotocol_not_supportedEPROTONOSUPPORTread_only_file_systemEROFSresource_deadlock_would_occurEDEADLKresource_unavailable_try_againEAGAINresult_out_of_rangeERANGEstate_not_recoverableENOTRECOVERABLEstream_timeoutETIMEtext_file_busyETXTBSYtimed_outETIMEDOUTtoo_many_files_openEMFILEtoo_many_files_open_in_systemENFILEtoo_many_linksEMLINKtoo_many_symbolic_link_levelsELOOPvalue_too_largeEOVERFLOWwrong_protocol_typeEPROTOTYPE* These are macro constants defined in header <cerrno>.Notice that errc is defined as an enum class while the possible values of errno are macro definitions.is_error_condition_enum is specialized for this type so its value is true.
https://www.cplusplus.com/reference/new/nothrow_t/
Type of the nothrow constant.This is a type specifically designed to overload the dynamic memory allocation operator functions operator new, operator new[], operator delete and operator delete[].It is an empty class defined in header <new>. This header also defines the standard constant nothrow, which is a value of this type specifically designed to call the overloaded operator functions.
https://www.cplusplus.com/cinttypes
Header with library support for width-based integral types.Including this header automatically includes also <cstdint> (which defines width-based integral types).
https://www.cplusplus.com/reference/new/bad_array_new_length/
exceptionbad_allocbad_array_new_lengthType of the exceptions thrown by array new-expressions in any of these cases:If the array size is less than zero.If the array size is greater than an implementation-defined limit.If the number of elements in the initializer list exceeds the number of elements to initialize.This class is derived from bad_alloc (which is itself derived from exception). See the exception class for the member definitions of standard exceptions.Its member what returns a null-terminated character sequence identifying the exception.
https://www.cplusplus.com/reference/exception/unexpected_handler/
This is a typedef of a void function with no parameters, used as the argument and return type in function set_unexpected.An unexpected handler function is a function called when a function throws an exception that is not in its dynamic-exception-specification (i.e., in its throw specifier).For more info, see the reference for set_unexpected, which is the function used to set a function of this type as the active unexpected handler.
https://www.cplusplus.com/reference/unordered_map/unordered_map/
Unordered maps are associative containers that store elements formed by the combination of a key value and a mapped value, and which allows for fast retrieval of individual elements based on their keys.In an unordered_map, the key value is generally used to uniquely identify the element, while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ.Internally, the elements in the unordered_map are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values (with a constant average time complexity on average).unordered_map containers are faster than map containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements.Unordered maps implement the direct access operator (operator[]) which allows for direct access of the mapped value using its key value as argument.Iterators in the container are at least forward iterators.
https://www.cplusplus.com/reference/exception/terminate_handler/
This is a typedef of a void function with no parameters, used as the argument and return type in function set_terminate.A terminate handler function is a function automatically called when an exception handling process has to be abandoned.For more info, see the reference for set_terminate, which is the function used to set a function of this type as the active terminate handler.
https://www.cplusplus.com/reference/regex/cmatch/
This is an instantiation of the match_results class template for matches on string literals (with const char* as its iterator type).The members of this class are those described for match_results, but using const char* as its BidirectionalIterator template parameter.Please, refer to match_results for further information.
https://www.cplusplus.com/reference/unordered_map/unordered_multimap/
Unordered multimaps are associative containers that store elements formed by the combination of a key value and a mapped value, much like unordered_map containers, but allowing different elements to have equivalent keys.In an unordered_multimap, the key value is generally used to uniquely identify the element, while the mapped value is an object with the content associated to this key. Types of key and mapped value may differ.Internally, the elements in the unordered_multimap are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values (with a constant average time complexity on average).Elements with equivalent keys are grouped together in the same bucket and in such a way that an iterator (see equal_range) can iterate through all of them.Iterators in the container are at least forward iterators.Notice that this container is not defined in its own header, but shares header <unordered_map> with unordered_map.
https://www.cplusplus.com/reference/system_error/is_error_condition_enum/
integral_constantis_error_condition_enumThis is a traits class to identify whether a particular type is an error condition enum type, and thus can be used to construct or assign values to objects of type error_condition.This header provides a default definition, which simply inherits from false_type, and a specialization for errc, which inherits from true_type. Custom error condition enum types should specialize it as inheriting from true_type in order to be used to construct error_condition objects. The standard error condition types io_errc and future_errc inherit true_type.
https://www.cplusplus.com/reference/chrono/high_resolution_clock/
The members of clock classes provide access to the current time_point.high_resolution_clock is the clock with the shortest tick period. It may be a synonym for system_clock or steady_clock.
https://www.cplusplus.com/reference/regex/wsmatch/
This is an instantiation of the match_results class template for matches on wstring objects (with wstring::const_iterator as its iterator type).The members of this class are those described for match_results, but using wstring::const_iterator as its BidirectionalIterator template parameter.Please, refer to match_results for further information.
https://www.cplusplus.com/reference/bitset/bitset/
A bitset stores bits (elements with only two possible values: 0 or 1, true or false, ...).The class emulates an array of bool elements, but optimized for space allocation: generally, each element occupies only one bit (which, on most systems, is eight times less than the smallest elemental type: char).Each bit position can be accessed individually: for example, for a given bitset named foo, the expression foo[3] accesses its fourth bit, just like a regular array accesses its elements. But because no elemental type is a single bit in most C++ environments, the individual elements are accessed as special references type (see bitset::reference).Bitsets have the feature of being able to be constructed from and converted to both integer values and binary strings (see its constructor and members to_ulong and to_string). They can also be directly inserted and extracted from streams in binary format (see applicable operators).The size of a bitset is fixed at compile-time (determined by its template parameter). For a class that also optimizes for space allocation and allows for dynamic resizing, see the bool specialization of vector (vector<bool>).
https://www.cplusplus.com/reference/exception/exception_ptr/
Smart pointer type that can refer to exception objects.It is a shared pointer-like type: The pointed exception is guaranteed to remain valid for as long as at least one exception_ptr points to it, potentially extending its lifetime beyond the scope of a catch statement or across threads.Different libraries may implement this type differently, but it shall at least support the following operations without throwing:Being default-constructed (acquiring a null-pointer value).Being copied, including being copied a null-pointer value (or nullptr).Being compared against another exception_ptr object (or nullptr) using either operator== or operator!=, where two null-pointers are always considered equivalent, and two non-null pointers are considered equivalent only if they refer to the same exception object.Being contextually convertible to bool, as false if having null-pointer value, and as true otherwise.Being swapped, and being destructed.The type is also required to not be implicitly convertible to an arithmetic, enumeration, or pointer type.Performing any other operation on the object (such as dereferencing it), if at all supported by the library implementation, causes undefined behavior.Objects of this type are obtained by calling: current_exception, make_exception_ptr or nested_exception::nested_ptr, and can be accessed by rethrowing the pointed exception calling rethrow_exception.
https://www.cplusplus.com/reference/map/map/
Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order.In a map, the key values are generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type, which is a pair type combining both:Â typedef pair<const Key, T> value_type;Internally, the elements in a map are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).map containers are generally slower than unordered_map containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.The mapped values in a map can be accessed directly by their corresponding key using the bracket operator ((operator[]).Maps are typically implemented as binary search trees.
https://www.cplusplus.com/reference/forward_list/forward_list/
Forward lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence.Forward lists are implemented as singly-linked lists; Singly linked lists can store each of the elements they contain in different and unrelated storage locations. The ordering is kept by the association to each element of a link to the next element in the sequence.The main design difference between a forward_list container and a list container is that the first keeps internally only a link to the next element, while the latter keeps two links per element: one pointing to the next element and one to the preceding one, allowing efficient iteration in both directions, but consuming additional storage per element and with a slight higher time overhead inserting and removing elements. forward_list objects are thus more efficient than list objects, although they can only be iterated forwards. Compared to other base standard sequence containers (array, vector and deque), forward_list perform generally better in inserting, extracting and moving elements in any position within the container, and therefore also in algorithms that make intensive use of these, like sorting algorithms.The main drawback of forward_lists and lists compared to these other sequence containers is that they lack direct access to the elements by their position; For example, to access the sixth element in a forward_list one has to iterate from the beginning to that position, which takes linear time in the distance between these. They also consume some extra memory to keep the linking information associated to each element (which may be an important factor for large lists of small-sized elements).The forward_list class template has been designed with efficiency in mind: By design, it is as efficient as a simple handwritten C-style singly-linked list, and in fact is the only standard container to deliberately lack a size member function for efficiency considerations: due to its nature as a linked list, having a size member that takes constant time would require it to keep an internal counter for its size (as list does). This would consume some extra storage and make insertion and removal operations slightly less efficient. To obtain the size of a forward_list object, you can use the distance algorithm with its begin and end, which is an operation that takes linear time.
https://www.cplusplus.com/reference/utility/pair/
This class couples together a pair of values, which may be of different types (T1 and T2). The individual values can be accessed through its public members first and second.Pairs are a particular case of tuple.
https://www.cplusplus.com/is_fundamental
integral_constantis_fundamentalTrait class that identifies whether T is a fundamental type.It inherits from integral_constant as being either true_type or false_type, depending on whether T is one of the following types:fundamental arithmetic typesintegral typesboolcharchar16_tchar32_twchar_tsigned charshort intintlong intlong long intunsigned charunsigned short intunsigned intunsigned long intunsigned long long intfloating point typesfloatdoublelong doublevoidvoidnull pointerstd::nullptr_tAll fundamental types, along with all their aliases (like those in cstdint), are considered fundamental types by this class, including their const and volatile qualified variants.Enums, along with pointers, references, classes and functions are not considered fundamental types in C++.This is a compound type trait defined with the same behavior as:1234template<class T>struct is_fundamental : std::integral_constant < bool,         is_integral<T>::value || is_floating_point<T>::value || is_void<T>:: value ||         is_same<nullptr_t, typename remove_cv<T>::type>::value> {};
https://www.cplusplus.com/reference/new/bad_alloc/
exceptionbad_allocType of the exceptions thrown by the standard definitions of operator new and operator new[] when they fail to allocate the requested storage space.This class is derived from exception. See the exception class for the member definitions of standard exceptions.Its member what returns a null-terminated character sequence identifying the exception.
https://www.cplusplus.com/reference/chrono/time_point/
A time_point object expresses a point in time relative to a clock's epoch.Internally, the object stores an object of a duration type, and uses the Clock type as a reference for its epoch.
https://www.cplusplus.com/reference/ratio/ratio_multiply/
This class template alias generates a ratio type that is the multiplication of the ratio types R1 and R2.The resulting type is the same as if ratio_multiply was defined as:12template <typename R1, typename R2>using ratio_multiply = std::ratio < R1::num * R2::num, R1::den * R2::den >;A program shall not cause any expression in the above definition to expand to values not representable as an intmax_t.
https://www.cplusplus.com/reference/typeinfo/type_info/
Stores information about a type.An object of this class is returned by the typeid operator (as a const-qualified lvalue). Although its actual dynamic type may be of a derived class.It can be used to compare two types or to retrieve information identifying a type.typeid can be applied to any type or any expression that has a type.If applied to a reference type (lvalue), the type_info returned identifies the referenced type. Any const or volatile qualified type is identified as its unqualified equivalent. A typedef type is considered the same as its aliased type.When typeid is applied to a reference or dereferenced pointer to an object of a polymorphic class type (a class declaring or inheriting a virtual function), it considers its dynamic type (i.e., the type of the most derived object). This requires the RTTI (Run-time type information) to be available.When typeid is applied to a dereferenced null pointer, a bad_typeid exception is thrown.The lifetime of the object returned by typeid extends to the end of the program.C++98C++11The copy and assignment operators of type_info are private: objects of this type cannot be copied.The copy and assignment operators of type_info are deleted: objects of this type cannot be copied.See type_index for a wrapper class that adapts type_info values to make them copyable and indexable with standard hash values.
https://www.cplusplus.com/reference/ratio/ratio_less/
This type inherits from the appropriate integral_constant type (either true_type or false_type) to signal whether R1 compares less than R2The resulting type is the same as if ratio_less was defined as:12template <class R1, class R2>struct ratio_less : integral_constant < bool, R1::num*R2::den < R2::num*R1::den > {};
https://www.cplusplus.com/reference/regex/regex_error/
Objects of this exception type are thrown by the elements of the regex library.It inherits from the standard exception runtime_error, and has a special public member function, code, which returns a specific code of type regex_constants::error_type depending on the kind of error that threw it:flagerrorerror_collateThe expression contained an invalid collating element name.error_ctypeThe expression contained an invalid character class name.error_escapeThe expression contained an invalid escaped character, or a trailing escape.error_backrefThe expression contained an invalid back reference.error_brackThe expression contained mismatched brackets ([ and ]).error_parenThe expression contained mismatched parentheses (( and )).error_braceThe expression contained mismatched braces ({ and }).error_badbraceThe expression contained an invalid range between braces ({ and }).error_rangeThe expression contained an invalid character range.error_spaceThere was insufficient memory to convert the expression into a finite state machine.error_badrepeatThe expression contained a repeat specifier (one of *?+{) that was not preceded by a valid regular expression.error_complexityThe complexity of an attempted match against a regular expression exceeded a pre-set level.error_stackThere was insufficient memory to determine whether the regular expression could match the specified character sequence.
https://www.cplusplus.com/reference/ratio/ratio_less_equal/
This type inherits from the appropriate integral_constant type (either true_type or false_type) to signal whether R1 compares less than or equal to R2The resulting type is the same as if ratio_less_equal was defined as:12template <class R1, class R2>struct ratio_less_equal : integral_constant < bool, !ratio_less<R2,R1>::value > {};
https://www.cplusplus.com/reference/exception/bad_exception/
exceptionbad_exceptionThis is a special type of exception specifically designed to be listed in the dynamic-exception-specifier of a function (i.e., in its throw specifier).If a function with bad_exception listed in its dynamic-exception-specifier throws an exception not listed in it and unexpected rethrows it (or throws any other exception also not in the dynamic-exception-specifier), a bad_exception is automatically thrown.Its member what returns a null-terminated character sequence identifying the exception.Under certain implementations of current_exception (since C++11), this exception is thrown to signal a failed attempt to copy an exception object.
https://www.cplusplus.com/reference/regex/wregex/
This is an instantiation of the basic_regex class template for characters of type wchar_t.The members of this class are those described for basic_regex, but using wchar_t as its first template parameter (charT), and the corresponding regex_traits<wchar_t> as its second template parameter (traits).Please, refer to basic_regex for further information.
https://www.cplusplus.com/reference/queue/queue/
queues are a type of container adaptor, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other.queues are implemented as containers adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are pushed into the "back" of the specific container and popped from its "front".The underlying container may be one of the standard container class template or some other specifically designed container class. This underlying container shall support at least the following operations:emptysizefrontbackpush_backpop_frontThe standard container classes deque and list fulfill these requirements. By default, if no container class is specified for a particular queue class instantiation, the standard container deque is used.
https://www.cplusplus.com/reference/regex/sub_match/
Stores each of the individual matches of a match_results object filled by one of the regex algorithms regex_match or regex_search, or by the regex iterators (regex_iterator and regex_token_iterator).These matches are sequences of characters. But objects of this class do not store the sequence of characters itself, but instead, the class derives from pair to hold a pair of bidirectional iterators to the initial and past-the-end characters of a sequence, and provides reference semantics to this sequence.This class adds to the data inherited by pair a public member variable of type bool, named matched. This member holds the state of the object (either matched or not matched). Objects constructed with its default constructor will have this member set to false, while objects part of a match_results object will have it set to true.Objects of this type can be converted to string objects (or the appropriate basic_string type), and, when compared, behave as such. They also have a length member that behaves like its string counterpart.Four instantiations of this basic class exist in the standard header <regex> for the most common cases:1234typedef sub_match<const char*> csub_match;typedef sub_match<const wchar_t*> wcsub_match;typedef sub_match<string::const_iterator> ssub_match;typedef sub_match<wstring::const_iterator> wssub_match;
https://www.cplusplus.com/reference/ratio/ratio_greater_equal/
This type inherits from the appropriate integral_constant type (either true_type or false_type) to signal whether R1 compares greater than or equal to R2The resulting type is the same as if ratio_greater_equal was defined as:12template <class R1, class R2>struct ratio_greater_equal : integral_constant < bool, !ratio_less<R1,R2>::value > {};
https://www.cplusplus.com/reference/functional/unary_negate/
Unary function object class whose call returns the opposite of another unary function, passed to its constructor.Object of type unary_negate are generally constructed using function not1.The class is defined with the same behavior as:C++98C++11123456789template <class Predicate> class unary_negate  : public unary_function <typename Predicate::argument_type,bool>{protected:  Predicate fn_;public:  explicit unary_negate (const Predicate& pred) : fn_ (pred) {}  bool operator() (const typename Predicate::argument_type& x) const {return !fn_(x);}};12345678910template <class Predicate> class unary_negate{protected:  Predicate fn_;public:  explicit unary_negate (const Predicate& pred) : fn_ (pred) {}  bool operator() (const typename Predicate::argument_type& x) const {return !fn_(x);}  typedef typename Predicate::argument_type argument_type;  typedef bool result_type;};
https://www.cplusplus.com/reference/codecvt/codecvt_utf16/
locale::facetcodecvt_basecodecvtcodecvt_utf16Converts between multibyte sequences encoded in UTF-16 and sequences of their equivalent fixed-width characters of type Elem (either UCS-2 or UCS-4).Notice that if Elem is a 32bit-width character type (such as char32_t), and MaxCode is 0x10ffff, the conversion performed is between UTF-16 and UTF-32. To convert between UTF-16 and UTF-8, see codecvt_utf8_utf16.The facet uses Elem as its internal character type, and char as its external character type (encoded as UTF-16). Therefore:Member in converts from UTF-16 to its fixed-width character equivalent.Member out converts from the fixed-width wide character encoding to UTF-16.
https://www.cplusplus.com/reference/chrono/system_clock/
Clock classes provide access to the current time_point.Specifically, system_clock is a system-wide realtime clock.
https://www.cplusplus.com/reference/regex/wcsub_match/
This is an instantiation of the sub_match class template for matches on wide string literals of type const wchar_t*.The members of this class are those described for sub_match, but using const wchar_t* as its BidirectionalIterator template parameter.Please, refer to sub_match for further information.
https://www.cplusplus.com/reference/chrono/treat_as_floating_point/
This is a traits class to identify which types of count representations (as those used internally by duration) act as floating-point types, and thus allow for fractional counts.The standard only provides the default definition, which is the same as the is_floating_point trait for the type, but a specific type of count representation can specialize this template to be either a true_type or a false_type.
https://www.cplusplus.com/reference/exception/exception/
Base class for standard exceptions.All objects thrown by components of the standard library are derived from this class. Therefore, all standard exceptions can be caught by catching this type by reference.It is declared as:C++98C++1112345678class exception {public:  exception () throw();  exception (const exception&) throw();  exception& operator= (const exception&) throw();  virtual ~exception() throw();  virtual const char* what() const throw();}12345678class exception {public:  exception () noexcept;  exception (const exception&) noexcept;  exception& operator= (const exception&) noexcept;  virtual ~exception();  virtual const char* what() const noexcept;}
https://www.cplusplus.com/reference/ratio/ratio/
This template is used to instantiate types that represent a finite rational number denoted by a numerator and a denominator.The numerator and denominator are implemented as compile-time constants of type intmax_t.Notice that the ratio is not represented by an object of this type, but by the type itself, which uses compile-time constant members to define the ratio. Therefore, ratio can only be used to express constexpr constants and cannot contain any value.Types of this template are used on the standard class duration (see header chrono).
https://www.cplusplus.com/reference/regex/regex_traits/
Regex traits classes specify some of the semantics for regular expressions.Every basic_regex object uses the member functions provided by its regex traits class to perform some of its most basic tasks.regex_traits is a class template used as default regex traits by standard basic_regex objects.[Note: regex_traits refers to the name of a class template defined in header <regex>, while regex traits (no underscore) refers generically to a certain kind of classes. This page makes reference to both.]An instantitation of basic_regex other that regex can use a different class as regex traits class to customize the behavior of the basic_regex object.A custom regex traits does not need to have the standard regex_traits class template as a base class, but it shall define the same members and respect its required semantics.The reference in these pages includes in its description both the behavior of the standard regex_traits class and the required behavior for other classes that intend to be used as regex traits classes.
https://www.cplusplus.com/reference/regex/regex/
This is an instantiation of the basic_regex class template for characters of type char.The members of this class are those described for basic_regex, but using char as its first template parameter (charT), and the corresponding regex_traits<char> as its second template parameter (traits).Please, refer to basic_regex for further information.
https://www.cplusplus.com/reference/chrono/common_type/
This is a specialization of the standard traits class common_type. It defines the most precise duration type between its two template arguments.The default definition returns a duration type with common_type<Rep1,Rep2> as its first template argument and the greatest common divisor of Period1 and Period2 as its second template argument.A custom count representation type can provide its own specialization of this template.
https://www.cplusplus.com/reference/system_error/error_condition/
Objects of this type hold a condition value associated with a category.Objects of this type describe errors in a generic way so that they may be portable across different systems. This is in contrast with error_code objects, that may contain system-specific information.Because error_condition objects can be compared with error_code objects directly by using relational operators, error_condition objects are generally used to check whether a particular error_code obtained from the system matches a specific error condition no matter the system.The categories associated with the error_condition and the error_code define the equivalences between them.
https://www.cplusplus.com/reference/ratio/ratio_greater/
This type inherits from the appropriate integral_constant type (either true_type or false_type) to signal whether R1 compares greater than to R2The resulting type is the same as if ratio_less_equal was defined as:12template <class R1, class R2>struct ratio_greater : integral_constant < bool, ratio_less<R2,R1>::value > {};
https://www.cplusplus.com/reference/unordered_set/unordered_set/
Unordered sets are containers that store unique elements in no particular order, and which allow for fast retrieval of individual elements based on their value.In an unordered_set, the value of an element is at the same time its key, that identifies it uniquely. Keys are immutable, therefore, the elements in an unordered_set cannot be modified once in the container - they can be inserted and removed, though.Internally, the elements in the unordered_set are not sorted in any particular order, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average).unordered_set containers are faster than set containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements.Iterators in the container are at least forward iterators.
https://www.cplusplus.com/reference/functional/binary_negate/
Binary function object class whose call returns the opposite of another binary function, passed to its constructor.Object of type binary_negate are generally constructed using function not2.The class is defined with the same behavior as:C++98C++11123456789101112template <class Predicate> class binary_negate  : public binary_function <typename Predicate::first_argument_type,                            typename Predicate::second_argument_type, bool>{protected:  Predicate fn_;public:  explicit binary_negate ( const Predicate& pred ) : fn_ (pred) {}  bool operator() (const typename Predicate::first_argument_type& x,                   const typename Predicate::second_argument_type& y) const  { return !fn_(x,y); }};1234567891011template <class Predicate> class binary_negate{protected:  Predicate fn_;public:  explicit binary_negate (const Predicate& pred) : fn_ (pred) {}  bool operator() (const typename Predicate::argument_type& x) const {return !fn_(x,y);}  typedef typename Predicate::first_argument_type  first_argument_type;  typedef typename Predicate::second_argument_type second_argument_type;  typedef bool result_type;};
https://www.cplusplus.com/reference/vector/vector/
Vectors are sequence containers representing arrays that can change in size.Just like arrays, vectors use contiguous storage locations for their elements, which means that their elements can also be accessed using offsets on regular pointers to its elements, and just as efficiently as in arrays. But unlike arrays, their  size can change dynamically, with their storage being handled automatically by the container.Internally, vectors use a dynamically allocated array to store their elements. This array may need to be reallocated in order to grow in size when new elements are inserted, which implies allocating a new array and moving all elements to it. This is a relatively expensive task in terms of processing time, and thus, vectors do not reallocate each time an element is added to the container.Instead, vector containers may allocate some extra storage to accommodate for possible growth, and thus the container may have an actual capacity greater than the storage strictly needed to contain its elements (i.e., its size). Libraries can implement different strategies for growth to balance between memory usage and reallocations, but in any case, reallocations should only happen at logarithmically growing intervals of size so that the insertion of individual elements at the end of the vector can be provided with amortized constant time complexity (see push_back).Therefore, compared to arrays, vectors consume more memory in exchange for the ability to manage storage and grow dynamically in an efficient way.Compared to the other dynamic sequence containers (deques, lists and forward_lists), vectors are very efficient accessing its elements (just like arrays) and relatively efficient adding or removing elements from its end. For operations that involve inserting or removing elements at positions other than the end, they perform worse than the others, and have less consistent iterators and references than lists and forward_lists.
https://www.cplusplus.com/reference/unordered_set/unordered_multiset/
Unordered multisets are containers that store elements in no particular order, allowing fast retrieval of individual elements based on their value, much like unordered_set containers, but allowing different elements to have equivalent values.In an unordered_multiset, the value of an element is at the same time its key, used to identify it. Keys are immutable, therefore, the elements in an unordered_multiset cannot be modified once in the container - they can be inserted and removed, though.Internally, the elements in the unordered_multiset are not sorted in any particular, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average).Elements with equivalent values are grouped together in the same bucket and in such a way that an iterator (see equal_range) can iterate through all of them.Iterators in the container are at least forward iterators.Notice that this container is not defined in its own header, but shares header <unordered_set> with unordered_set.
https://www.cplusplus.com/reference/chrono/duration_values/
This is a traits class to provide the limits and zero value of the type used to represent the count in a duration object.All library implementations provide at least a default definition, which is equivalent to:12345template <class Rep> struct duration_values {  static constexpr Rep zero() { return Rep(0); }  static constexpr Rep min() { return numeric_limits<Rep>::lowest(); }  static constexpr Rep max() { return numeric_limits<Rep>::max(); }}A specific type of count representation can specialize this template to provide specific values.
https://www.cplusplus.com/reference/ratio/ratio_add/
This class template alias generates a ratio type that is the sum of the ratio types R1 and R2.The resulting type is the same as if ratio_add was defined as:12template <typename R1, typename R2>using ratio_add = ratio < R1::num*R2::den+R2::num*R1::den, R1::den*R2::den >;
https://www.cplusplus.com/reference/chrono/duration/
A duration object expresses a time span by means of a count and a period.Internally, the object stores the count as an object of member type rep (an alias of the first template parameter, Rep), which can be retrieved by calling member function count.This count is expresed in terms of periods. The length of a period is integrated in the type (on compile time) by its second template parameter (Period), which is a ratio type that expresses the number (or fraction) of seconds that elapse in each period.
https://www.cplusplus.com/reference/new/new_handler/
This is a typedef of a void function with no parameters, used as the argument and return type in function set_new_handler.A new-handler function is a function that is called by the standard definition of functions operator new and operator new[] when they fail to allocate memory.For more info, see the reference for set_new_handler, which is the function used to set a function of this type as the active new-handler.
https://www.cplusplus.com/reference/codecvt/codecvt_mode/
Enum type that specifies endianness options as a bitmask for the following class templates: codecvt_utf8, codecvt_utf16 or codecvt_utf8_utf16.labelvaluedescriptionconsume_header4An optional initial header sequence (BOM) is read to determine whether a multibyte sequence converted in is big-endian or little-endian.generate_header2An initial header sequence (BOM) shall be generated to indicate whether a multibyte sequence converted out is big-endian or little-endian.little_endian1The multibyte sequence generated on conversions out shall be little-endian (as opposed to the default big-endian).This is a bitmask type: each of the labels is considered a flag that can be individually set or not in a particular value of this type (this can be achieved by combining the flags using bitwise OR operations). Therfore, 0 is also a valid value that represents the absence of all flags.
https://www.cplusplus.com/reference/ratio/ratio_divide/
This class template alias generates a ratio type that is the result of dividing the ratio type R1 by the ratio type R2.The resulting type is the same as if ratio_divide was defined as:12template <typename R1, typename R2>using ratio_divide = ratio < R1::num * R2::den, R2::num * R1::den >;A program shall not cause any expression in the above definition to expand to values not representable as an intmax_t.
https://www.cplusplus.com/reference/ratio/ratio_subtract/
This class template alias generates a ratio type that is the difference between the ratio types R1 and R2.The resulting type is the same as if ratio_subtract was defined as:12template <typename R1, typename R2>using ratio_subtract = std::ratio < R1::num*R2::den-R2::num*R1::den, R1::den*R2::den >;A program shall not cause any expression in the above definition to expand to values not representable as an intmax_t.
https://www.cplusplus.com/reference/condition_variable/cv_status/
Type that indicates whether a function returned because of a timeout or not.Values of this type are returned by the wait_for and wait_until members of condition_variable and condition_variable_any.It is defined as:Â enum class cv_status { no_timeout, timeout };
https://www.cplusplus.com/reference/system_error/system_error/
exceptionruntime_errorsystem_errorThis class defines the type of objects thrown as exceptions to report conditions originating during runtime from the operating system or other low-level application program interfaces which have an associated error_code.The class inherits from runtime_error, to which it adds an error_code as member code (and defines a specialized what member).
https://www.cplusplus.com/reference/regex/wssub_match/
This is an instantiation of the sub_match class template for matches on wstring objects.The members of this class are those described for sub_match, but using wstring::const_iterator as its BidirectionalIterator template parameter.Please, refer to sub_match for further information.
https://www.cplusplus.com/reference/regex/match_results/
Container-like class used to store the matches found on the target sequence of characters after a regex matching operation, each match being of the corresponding sub_match type.It is automatically filled by regex_match, regex_search or a regex_iterator with the results of the matching operation. The elements in match_results objects are const-qualified, and thus are not meant to be modified outside of these functions.When constructed, match_results objects have no result state (i.e., they are not ready). Once they have been used as the proper argument in a call to either regex_match or regex_search, they acquire a established result state, and become ready (this can be checked by calling member function match_results::ready). Values returned by dereferencing a regex_iterator that points to a valid location are always ready.Once ready, the object can either be empty or non-empty, depending on whether the target sequence was successfully matched against the expression. If successful, it is not empty and contains a series of sub_match objects: the first sub_match element corresponds to the entire match, and, if the regex expression contained sub-expressions to be matched (i.e., parentheses-delimited groups), their corresponding sub-matches are stored as successive sub_match elements in the match_results object.These sub-matches can be accessed as if the match_results object were a container, or directly using members such as str, length or position.If the match_results object was used with regex_search, the part of the target sequence that was not part of the match can be accessed using members prefix and suffix.Objects of match_results type that are ready can also be used to format a character sequence using the information they contain by using member function match_results::format.The classes cmatch and smatch are instantiations of this class for narrow characters (char). wcmatch and wsmatch are their respective wide character versions (wchar_t). Defined in the <regex> standard header as:1234typedef match_results<const char*> cmatch;typedef match_results<const wchar_t*> wcmatch;typedef match_results<string::const_iterator> smatch;typedef match_results<wstring::const_iterator> wsmatch;
https://www.cplusplus.com/reference/regex/smatch/
This is an instantiation of the match_results class template for matches on string objects (with string::const_iterator as its iterator type).The members of this class are those described for match_results, but using string::const_iterator as its BidirectionalIterator template parameter.Please, refer to match_results for further information.
https://www.cplusplus.com/reference/vector/vector-bool/
This is a specialized version of vector, which is used for elements of type bool and optimizes for space.It behaves like the unspecialized version of vector, with the following changes:The storage is not necessarily an array of bool values, but the library implementation may optimize storage so that each value is stored in a single bit.Elements are not constructed using the allocator object, but their value is directly set on the proper bit in the internal storage.Member function flip and a new signature for member swap.A special member type, reference, a class that accesses individual bits in the container's internal storage with an interface that emulates a bool reference. Conversely, member type const_reference is a plain bool.The pointer and iterator types used by the container are not necessarily neither pointers nor conforming iterators, although they shall simulate most of their expected behavior.These changes provide a quirky interface to this specialization and favor memory optimization over processing (which may or may not suit your needs). In any case, it is not possible to instantiate the unspecialized template of vector for bool directly. Workarounds to avoid this range from using a different type (char, unsigned char) or container (like deque) to use wrapper types or further specialize for specific allocator types.bitset is a class that provides a similar functionality for fixed-size arrays of bits.
https://www.cplusplus.com/reference/list/list/
Lists are sequence containers that allow constant time insert and erase operations anywhere within the sequence, and iteration in both directions.List containers are implemented as doubly-linked lists; Doubly linked lists can store each of the elements they contain in different and unrelated storage locations. The ordering is kept internally by the association to each element of a link to the element preceding it and a link to the element following it.They are very similar to forward_list: The main difference being that forward_list objects are single-linked lists, and thus they can only be iterated forwards, in exchange for being somewhat smaller and more efficient.Compared to other base standard sequence containers (array, vector and deque), lists perform generally better in inserting, extracting and moving elements in any position within the container for which an iterator has already been obtained, and therefore also in algorithms that make intensive use of these, like sorting algorithms.The main drawback of lists and forward_lists compared to these other sequence containers is that they lack direct access to the elements by their position; For example, to access the sixth element in a list, one has to iterate from a known position (like the beginning or the end) to that position, which takes linear time in the distance between these. They also consume some extra memory to keep the linking information associated to each element (which may be an important factor for large lists of small-sized elements).
https://www.cplusplus.com/reference/system_error/error_code/
Objects of this type hold an error code value associated with a category.The operating system and other low-level applications and libraries generate numerical error codes to represent possible results. These numerical values may carry essential information for a specific platform, but be non-portable from one platform to another.Objects of this class associate such numerical codes to error categories, so that they can be interpreted when needed as more abstract (and portable) error conditions.
https://www.cplusplus.com/reference/stack/stack/
Stacks are a type of container adaptor, specifically designed to operate in a LIFO context (last-in first-out), where elements are inserted and extracted only from one end of the container.stacks are implemented as container adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are pushed/popped from the "back" of the specific container, which is known as the top of the stack.The underlying container may be any of the standard container class templates or some other specifically designed container class. The container shall support the following operations:emptysizebackpush_backpop_backThe standard container classes vector, deque and list fulfill these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container deque is used.
https://www.cplusplus.com/reference/ratio/ratio_equal/
This type inherits from the appropriate integral_constant type (either true_type or false_type) to signal whether R1 compares equal to R2The resulting type is the same as if ratio_equal was defined as:12template <class R1, class R2>struct ratio_equal : integral_constant<bool, R1::num==R2::num && R1::den==R2::den> {};
https://www.cplusplus.com/atomic
Objects of atomic types contain a value of a particular type (T).The main characteristic of atomic objects is that access to this contained value from different threads cannot cause data races (i.e., doing that is well-defined behavior, with accesses properly sequenced). Generally, for all other objects, the possibility of causing a data race for accessing the same object concurrently qualifies the operation as undefined behavior.Additionally, atomic objects have the ability to synchronize access to other non-atomic objects in their threads by specifying different memory orders.
https://www.cplusplus.com/reference/exception/nested_exception/
Component for exception classes that captures the currently handled exception as nested.A class that derives from both this class and some other exception class, that can hold the properties of both the currently handled exception (as its nested exception) and this other exception (its outer exception).Objects with nested exceptions are generally constructed by calling throw_with_nested with the outer exception object as argument. The returned object has the same properties and members as the outer exception, but carry additional information related to the nested exception and includes two member functions to access this nested exception: nested_ptr and rethrow_nested.It is declared as:12345678910class nested_exception {public:  nested_exception() noexcept;  nested_exception (const nested_exception&) noexcept = default;  nested_exception& operator= (const nested_exception&) noexcept = default;  virtual ~nested_exception() = default;  [[noreturn]] void rethrow_nested() const;  exception_ptr nested_ptr() const noexcept;}
https://www.cplusplus.com/reference/set/set/
Sets are containers that store unique elements following a specific order.In a set, the value of an element also identifies it (the value is itself the key, of type T), and each value must be unique. The value of the elements in a set cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container.Internally, the elements in a set are always sorted following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).set containers are generally slower than unordered_set containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.Sets are typically implemented as binary search trees.
https://www.cplusplus.com/reference/deque/deque/
deque (usually pronounced like "deck") is an irregular acronym of double-ended queue. Double-ended queues are sequence containers with dynamic sizes that can be expanded or contracted on both ends (either its front or its back).Specific libraries may implement deques in different ways, generally as some form of dynamic array. But in any case, they allow for the individual elements to be accessed directly through random access iterators, with storage handled automatically by expanding and contracting the container as needed.Therefore, they provide a functionality similar to vectors, but with efficient insertion and deletion of elements also at the beginning of the sequence, and not only at its end. But, unlike vectors, deques are not guaranteed to store all its elements in contiguous storage locations: accessing elements in a deque by offsetting a pointer to another element causes undefined behavior.Both vectors and deques provide a very similar interface and can be used for similar purposes, but internally both work in quite different ways: While vectors use a single array that needs to be occasionally reallocated for growth, the elements of a deque can be scattered in different chunks of storage, with the container keeping the necessary information internally to provide direct access to any of its elements in constant time and with a uniform sequential interface (through iterators). Therefore, deques are a little more complex internally than vectors, but this allows them to grow more efficiently under certain circumstances, especially with very long sequences, where reallocations become more expensive.For operations that involve frequent insertion or removals of elements at positions other than the beginning or the end, deques perform worse and have less consistent iterators and references than lists and forward lists.
https://www.cplusplus.com/reference/typeinfo/bad_typeid/
exceptionbad_typeidType of the exceptions thrown by typeid when applied on a pointer to a polymorphic type which has a null pointer value.Its member what returns a null-terminated character sequence identifying the exception.
https://www.cplusplus.com/reference/map/multimap/
Multimaps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order, and where multiple elements can have equivalent keys.In a multimap, the key values are generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type, which is a pair type combining both:Â typedef pair<const Key, T> value_type;Internally, the elements in a multimap are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).multimap containers are generally slower than unordered_multimap containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.Multimaps are typically implemented as binary search trees.
https://www.cplusplus.com/reference/system_error/is_error_code_enum/
integral_constantis_error_code_enumThis is a traits class to identify whether a particular type is an error code enum type, and thus can be used to construct or assign values to objects of type error_code.The standard header only provides the default definition, which simply inherits from false_type. But it should be specialized as inheriting from true_type to enable the construction of error_code object from error code enum types. The standard error condition types io_errc and future_errc inherit true_type.
https://www.cplusplus.com/reference/system_error/error_category/
This type serves as a base class for specific category types.Category types are used to identify the source of an error. They also define the relation between error_code and error_condition objects of its category, as well as the message set for error_code objects.Objects of these types have no distinct values and are not-copyable and not-assignable, and thus can only be passed by reference. As such, only one object of each of these types shall exist, each uniquely identifying its own category: all error codes and conditions of a same category shall return a reference to same object.Some standard objects are of a type derived from this class. A reference to them can be obtained by calling a specific global function for each:headercategory function<system_error>generic_category system_category<ios> <iostream>iostream_category<future>future_category
https://www.cplusplus.com/reference/typeinfo/bad_cast/
exceptionbad_castType of the exceptions thrown by dynamic_cast when it fails the run-time check performed on references to polymorphic class types.The run-time check fails if the object would be an incomplete object of the destination type.Its member what returns a null-terminated character sequence identifying the exception.Some functions in the standard library may also throw this exception to signal a type-casting error.
https://www.cplusplus.com/reference/array/array/
Arrays are fixed-size sequence containers: they hold a specific number of elements ordered in a strict linear sequence.Internally, an array does not keep any data other than the elements it contains (not even its size, which is a template parameter, fixed on compile time). It is as efficient in terms of storage size as an ordinary array declared with the language's bracket syntax ([]). This class merely adds a layer of member and global functions to it, so that arrays can be used as standard containers.Unlike the other standard containers, arrays have a fixed size and do not manage the allocation of its elements through an allocator: they are an aggregate type encapsulating a fixed-size array of elements. Therefore, they cannot be expanded or contracted dynamically (see vector for a similar container that can be expanded).Zero-sized arrays are valid, but they should not be dereferenced (members front, back, and data).Unlike with the other containers in the Standard Library, swapping two array containers is a linear operation that involves swapping all the elements in the ranges individually, which generally is a considerably less efficient operation. On the other side, this allows the iterators to elements in both containers to keep their original container association.Another unique feature of array containers is that they can be treated as tuple objects: The <array> header overloads the get function to access the elements of the array as if it was a tuple, as well as specialized tuple_size and tuple_element types.
